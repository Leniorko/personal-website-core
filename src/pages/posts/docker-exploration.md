---
setup: |
  import Layout from '../../layouts/BlogPost.astro'
  import SimpleCarousel from '../../components/SimpleCarousel.tsx'
title: Настраиваем Docker и разбираемся с его назначением
publishDate: 2021
name: Иван Егоров
value: 128
description: We do a little containerization
sliderOne: [{ url: "/personal-website-core/assets/legacy/dockerPost/s-1-1.jpg", description: "Создаём нужные папки (Programming — папка где я храню все свои проекты)"}, { url: "/personal-website-core/assets/legacy/dockerPost/s-2-1.jpg", description: "Инициализируем клиент"}, { url: "/personal-website-core/assets/legacy/dockerPost/s-3-1.jpg", description: "И инициализируем сервер"}]
sliderTwo: [{ url: "/personal-website-core/assets/legacy/dockerPost/s-2-1.jpg", description: "Инициализация клиента"}, { url: "/personal-website-core/assets/legacy/dockerPost/s-2-2.jpg", description: "Инициализация сервера. Я не уверен на счёт надобности второй строчки, но ладно."}]
sliderThree: [{ url: "/personal-website-core/assets/legacy/dockerPost/s-3-1.jpg", description: "Контейнер для клиента"}, { url: "/personal-website-core/assets/legacy/dockerPost/s-3-2.jpg", description: "Контейнер для сервера"}]
---
В этом тексте я настраиваю докер контейнеры для разработки прошу учесть что я сам ещё изучаю технологию и вообще большая часть всего что здесь написано взято откуда-то из интернета. Я учусь прямо пока пишу этот текст и пытаюсь обновлять его в связи со всеми «ой, я тут не совсем точно написал» или «чёрт, это не работает», которые я замечаю. Но я мог что-то упустить.

Ну и да. Данные контейнеры точно не для того что бы их использовать на рабочем сервере. Такие нужно настраивать отдельно.

## Подготовка

Перед тем как перейти к настройке Docker нужно создать хоть какой-то начальный проект. Буду делать это профессионально при помощи командной строки.

<SimpleCarousel client:only="react" carouselItemData={frontmatter.sliderOne}/>

![Hellow, World! На Go](/personal-website-core/assets/legacy/dockerPost/p-1.jpg)

Сервер без исполняемого файла, поэтому можно добавить стандартный Hello, World! на Go.

И это, в принципе, всё что нам нужно для начала работы. При желании можно убедиться в том, что всё работает. Но я уверенный в себе чад.

## Docker

Докер будет главной темой данного поста. Поэтому давайте сначала разберёмся что это вообще такое.

### Что такое Docker?

Докером называют «платформу» которая позволяет очень удобно создавать «контейнеры». Если понятие платформа не такое сложное, то с контейнером стоит разобраться.

Объяснение для тех, кто знаком с понятием виртуальной машины: Контейнер — это очень лёгкая виртуальная машина которая представляет из себя почти голое ядро операционной системы.

Для тех кто не знаком с понятием виртуально машины: Контейнер — это другая операционная система внутри вашей операционной системы. Только контейнер очень лёгкий и маленький (относительно вашей запущенной ОС). Он не имеет графической оболочки из-за чего вы не сможете открыть его и пользоваться им как Windows. Но с ней можно общаться при помощи текста в командной строке.

### А зачем это надо?

На самом деле много вариантов. Если говорить конкретно про мой проект, то мне это нужно для ускорения установки проекта на других устройствах и более удобного поднятия окружения для разработки. Потому что для установки и поднятия окружения мне нужно проделать эти команды (одна картинка — один терминал):

<SimpleCarousel client:only="react" carouselItemData={frontmatter.sliderTwo}/>

**Примечание**: на картинке с сервером есть airgolang — это инструмент позволяющий делать автоматический перезапуск работы кода при внесении изменений в код. Называется она просто air, но я у себя её переименовал что бы было более понятно.

Соответственно, для того что бы всё работало, мне нужно держать открытыми 2 терминала и каждый раз писать все эти команды, но мне лень.

![Примерно что-то такое я и делаю](/personal-website-core/assets/legacy/dockerPost/p-2.jpg)

Поэтому, написав несколько нужных файлов с нужными командами, мы сократим этот процесс до одной строчки.

![Та самая строчка](/personal-website-core/assets/legacy/dockerPost/p-3.jpg)

А за сценами этой команды будет творится магия, которую мы и будем настраивать дальше. Стоит заметить, что первое исполнение команды будет долгое, так как будет выполнятся установка всех зависимостей, но последующие запуски будут происходить очень быстро так как всё будет уже установлено.

Какие ещё плюсы у такого подхода?

1. Не нужно всё устанавливать в систему. Все системные настройки будут в контейнере, а система в которой мы работаем будет нетронута. Разработку можно вести прямо из своей системы так как изменения в файлах буду автоматически переданы в контейнер (при правильной настройке). При необходимости можно зайти в контейнер и работать там напрямую (такое позволяют современные редакторы кода).
2. Упрощается деплой на сервер. Не нужно настраивать всё на нём отдельно, устанавливать кучу всего. Можно просто запустить контейнер и он будет работать. Но, опять же, при правильной настройке.
3. Ну и из прошлого примера можно вынести вот такой плюс: Докер обеспечивает одинаковое поведения кода на любой машине. Так как он представляет из себя целую операционную систему со своим окружением.

Но тут же есть один жирный минус:

На разработку в контейнерах затрачивается сильно больше ресурсов чем при локальной разработке. Забегая вперёд, скажу, что все контейнеры что я создал занимают 2.5 гигабайта, кушают 800мб оперативки (во время работы может достигать 2 гигабайт). А контейнер с клиентом нагружает 30% моего процессора. У меня ещё неплохое железо, поэтому всё это не заметно, но на более слабом железе нагрузки могут быть ощутимы.

### Настройка контейнеров

От теории и объяснений прямо к делу. Для начала нужно поставить Docker. Если вы на Windows, дополнительно надо будет поставить WSL, если на Linux, то чуть проще. В любом случае установка не сложная, главное гуглите. [Начинать отсюда](https://www.docker.com/products/docker-desktop).

Забыл сказать раньше, один контейнер представляет из себя один самостоятельный сервис. То есть мы не можем запустить в одном контейнере сразу и клиент и сервер. Поэтому нам необходимо отдельно настроить клиентскую часть (React), серверную часть (Go) и базу данных (вообще не обязательно, можно использовать удалённую базу данных, благо MongoDB позволяет это сделать, но я хочу запихнуть её в контейнер).

И так, у нас имеется следующая структура:

![Структура проекта](/personal-website-core/assets/legacy/dockerPost/p-4.jpg)

Здесь вы можете заметить dockerfile в папке с сервером и клиентом, они и используются для настройки контейнера. Данный файл не требуется для базы данных и сейчас я объясню почему.

### Docker Hub или почему контейнеризация приложений это просто

Как я уже говорил, контейнер — это очень лёгкий образ операционной системы. И основу для этих контейнеров нужно где-то брать. Контейнер с нуля, конечно, сделать [можно](https://docs.docker.com/develop/develop-images/baseimages/), но нам не нужно.

DockerHub это хостинг для образов контейнеров, если точнее, для уже готовых Dockerfile. Именно на основе контейнеров отсюда мы и будем строить наше окружение.

Для интересующихся: [Вот dockerfile контейнера для Go](https://github.com/docker-library/golang/blob/94b50ae6a398dced36243c0f9034e168aa1ae833/1.16/alpine3.13/Dockerfile). Благодаря dockerhub мы можем использовать его одной строчкой и уже у себя провести дополнительные настройки.

Соответственно, учитывая выбранные мной технологии, мне нужны следующие контейнеры: [Node](https://hub.docker.com/_/node), [Golang](https://hub.docker.com/_/golang), [MongoDB](https://hub.docker.com/_/mongo?tab=description).

### Пишем Dockerfile

Вот содержимое моих докерфайлов:

<SimpleCarousel client:only="react" carouselItemData={frontmatter.sliderThree}/>

 их просто и честно скопипастил откуда-то из интернета.

Что же произойдёт при запуске этих файлов?

1. Докер скачает указанный родительский контейнер с DockerHub. Это самая первая строчка. FROM \<имя образа\>
2. Устанавливаем рабочую директорию внутри контейнера при помощи WORKDIR. Это нужно для того, что бы не было надобности каждый раз указывать абсолютный путь до папки с кодом.
3. Копируем файлы в контейнер и устанавливаем все зависимости. COPY для копирования. RUN для запуска команд. При помощи команды RUN можно не только устанавливать нужные зависимости. Но это всё что нам надо.
4. После чего запускаем приложение последней командой.

Так почему же мне не нужен Dockerfile для базы данных?

Потому что у меня нет локальной базы данных и мне не надо использовать какие-то настройки для неё. Для использования базы данных нам хватит стандартного контейнера из DockerHub. Он сам всё настроит и создаст базу данных. Но как его получить если нет Dockerfile?

Ну, вообще, при помощи командной строки. Но это не наш путь.

### Docker-compose или как мы контейнеры связывали

При помощи docker-compose мы можем одной командой запускать сразу несколько контейнеров. В том числе мы можем запустить просто образ с DockerHub. Более того, мы можем указать все предварительные настройки для того, что бы контейнеры могли между собой связываться и сохранять файлы проекта из контейнера в систему.

Без данного средства нужно писать большие команды в терминале. Для каждого контейнера отдельно. Выглядят они не очень приятно, поэтому я даже не буду их показывать.

Так как mongodb не требует никаких дополнительных настроек, сначала напишем настройки для неё

![Настройка контейнера базы данных и веб интерфейса для просмотра содержимого.](/personal-website-core/assets/legacy/dockerPost/p-5.jpg)

Здесь, как мне кажется, назначение каждого ключа интуитивно понятно из названия, но давайте подробно разберём как строится docker-compose файл.
Это .yml файл. В нём хранятся значения в виде \<ключ\>:\<значение\>
Значения могут быть вложенные. Вложенность определяется отступами (пробелами). Так, например, в файле выше ключ services имеет два значения mongo и mongo-express. Которые в свою очередь имеют свои вложенные значения. Ключ в качестве значений содержащий другие ключи со значениями — это словарь. Некоторые ключи так же могут содержать список значений перечисленных при помощи «-».

И так, что же описывает этот файл?

1. image — родительский контейнер нашего контейнера.
2. container_name — имя нашего контейнера
3. restart — описывает политику перезагрузки контейнера в случае фатальной ошибки. always говорит о том, что контейнер будет перезапускаться после любой ошибки сразу же.
4. ports — «открываем» порты контейнера для нашей машины. Указываются они в виде HOST:CONTAINER, соответственно мы можем назначить для одного порта контейнера другое значение на нашей машине. Например: 1000:2000 говорит о том, что порт 2000 у контейнера на нашей машине находится на порте 1000. Я предпочитаю не менять порт для своей машины и оставляю его таким же, как в контейнере.
5. volumes — тут мы описывает те папки которые хотим связать с папками контейнера. То есть изменения в этой папке локально изменят её внутри контейнера и наоборот. Записываются в том же формате HOST:CONTAINER
6. enviroment — задаём значения переменным среды. При помощи синтаксиса `${<ИМЯ_ПЕРЕМЕННОЙ>}` — я передаю значения из .env файла. Это нужно для тех данных, которые не следует раскрывать публично.
7. depends_on — описывает зависимость контейнера от других контейнеров. Так мы можем изменить порядок запуска контейнеров.

И если сейчас мы запустим этот файл, то мы сможем перейти в mongo-express по ссылке [http://localhost:8081](http://localhost:8081) и увидеть содержимое базы данных.

![Панель управления монго](/personal-website-core/assets/legacy/dockerPost/p-6.jpg)

**Примечание**: База данных collegeSupportChat создана благодаря отдельным настройкам, которые нужно описывать отдельным скриптом. Эти настройки находятся в папке docker-entrypoint-initdb.d . Все js и sh из этой папки исполняются автоматически при создании контейнера. Всё что я делаю, это создаю коллекцию «users» внутри базы данных так как без неё не создаться база данных. Для этого прописана одна команда в .js файле: db.createCollection("users");

Теперь настроим контейнеры для клиента и сервера.

![Панель управления монго](/personal-website-core/assets/legacy/dockerPost/p-7.jpg)

Настройка почти ни чем не отличается от mongo. Только теперь вместо image у нас build. build ищет dockerfile в указанной папке и запускает его.

 Единственная проблема которая возникла — у Go не работает перезагрузка программы при изменении кода. Вообще. Но она не работает только в Windows. Проверил работу в Ubuntu 20.04 LTS и всё работает идеально. К сожалению, альтернатив air не много и большая часть из них давно не обновлялась. Поэтому… грустно. Придётся на Windows вручную перезагружать весь контейнер. Благо он маленький.

И в принципе это всё. Теперь, если мы пропишем docker-compose up в консоли у нас поднимется 4 контейнера.

База данных
Интерфейс к базе данных
Клиент
Сервер
Я не был уверен что между ними есть коммуникация, а писать код лень. Как оказалось можно использовать ping для проверки соединения межу контейнера в форме:
`docker exec <from> ping <to>`
Так, например, что бы проверить соединение между сервером и базой данных нужно написать:
docker exec golang-backend ping mongo
И если пакеты идут, значит всё хорошо.

![Команда и её результаты](/personal-website-core/assets/legacy/dockerPost/p-8.jpg)

Если же подключение делать в коде, то всё что нам нужно — использовать имя контейнера как url и указывать порт к нему. То есть, что бы подключиться из контейнера с Go к базе данных, мне нужно будет делать запрос на:
[http://mongo:27017/](http://mongo:27017/)

И на этом настройка контейнеров закончена.

## Заключение

Хоть я и говорил что настройка контейнеров дело достаточно простое, оно, всё же, имеет свои подводные камни. Так, например, пытаясь разобраться почему не работает перезагрузка в Go контейнере, я потратил несколько часов.

А знаете что самое забавное?

Я решил что не буду использовать Docker дальше. :-)

Я не хочу им пользоваться из-за отсутствия перезагрузки у Go. Да и не нужен он мне, по факту. Docker стоит использовать когда настройка окружения сложная или требуются какие-то особые настройки системы (или вообще другая ОС) или когда реально много разных контейнеров. Но учитывая то, что у меня просто клиент и сервер (базу данных буду из облака использовать) в этом нет настоящей необходимости.

Вот такие вот дела.

Ссылка на репозиторий: [](https://github.com/Leniorko/college-support-chat)

Спасибо всем кто прочёл до конца.
Что буду писать дальше — не знаю.
